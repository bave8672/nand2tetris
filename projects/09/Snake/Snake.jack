class Snake {
    field int headX;
    field int headY;
    field List path;
    field int direction;
    field int length;

    constructor Snake new() {
        let headX = (Global.SCREEN_WIDTH() / 2);
        let headY = (Global.SCREEN_HEIGHT() / 2);
        let path = List.new(Global.RIGHT());
        let direction = Global.RIGHT();
        let length = 1;
        return this;
    }

    method int getHeadX() { return headX; }
    method int getHeadY() { return headY; }

    method void move(int dir) {
        var boolean validDir;
        var List p;

        let validDir = false;

        // move the head coordinates
        if (dir = Global.RIGHT()) {
            let headX = modScreenX(headX + Global.BLOCK_SIZE());
            let validDir = true;
        }
        if (dir = Global.LEFT()) {
            let headX = modScreenX(headX - Global.BLOCK_SIZE());
            let validDir = true;
        }
        if (dir = Global.DOWN()) {
            let headY = modScreenY(headY + Global.BLOCK_SIZE());
            let validDir = true;
        }
        if (dir = Global.UP()) {
            let headY = modScreenY(headY - Global.BLOCK_SIZE());
            let validDir = true;
        }

        // default case - move in current direction
        if (~(validDir)) {
            do move(direction);
            return;
        }

        // set the direction
        let direction = dir;

        // push direction onto the head of the path
        let p = List.new(dir);
        do p.setNext(path);
        let path = p;
        return;
    }

    method void draw() {
        do Screen.setColor(true);
        do drawInCurrentColor();
        return;
    }

    method void erase() {
        do Screen.setColor(false);
        do drawInCurrentColor();
        return;
    }

    method void drawInCurrentColor() {
        var int x; // current x
        var int y; // current y
        var List p; // current path segment
        var int len; // path length counter

        let x = headX;
        let y = headY;
        let p = path;
        let len = 0;

        // draw the head
        do Screen.drawRectangle(x, y, x + Global.BLOCK_SIZE_SUB_1(), y + Global.BLOCK_SIZE_SUB_1());

        // draw the paths backwards form the head
        while (len < length) {
            if (p.getData() = Global.DOWN()) {
                // move backwards (up)
                let y = modScreenY(y - Global.BLOCK_SIZE());
            }
            if (p.getData() = Global.UP()) {
                // move backwards (down)
                let y = modScreenY(y + Global.BLOCK_SIZE());
            }
            if (p.getData() = Global.LEFT()) {
                // move backwards (right)
                let x = modScreenX(x + Global.BLOCK_SIZE());
            }
            if (p.getData() = Global.RIGHT()) {
                // move backwards (left)
                let x = modScreenX(x - Global.BLOCK_SIZE());
            }

            do Screen.drawRectangle(x, y, x + Global.BLOCK_SIZE_SUB_1(), y + Global.BLOCK_SIZE_SUB_1());
            let p = p.getNext();
            let len = len + 1;
        }

        // dispose of paths not included in the body of the snake
        if (~(p = null)) {
            do p.dispose();
        }
        return;
    }

    method int modScreenX(int x) {
        return x & Global.SCREEN_WIDTH_SUB_1();
    }

    method int modScreenY(int y) {
        return y & Global.SCREEN_HEIGHT_SUB_1();
        // return y & 255;
    }

    method void print() {
        do Output.printString("x: ");
        do Output.printInt(headX);
        do Output.printString(" y: ");
        do Output.printInt(headY);
        do Output.printString(" path: ");
        do path.print();
        do Output.println();
        return;
    }

    method void dispose() {
        do path.dispose();
        do Memory.deAlloc(this);
        return;
    }
}
